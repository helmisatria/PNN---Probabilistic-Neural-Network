#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Feb 28 22:17:07 2018

@author: helmisatria - 1301154325
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import axes3d, Axes3D
from sklearn.cross_validation import train_test_split

dataSet = np.genfromtxt('data_train_PNN.txt', skip_header=1)
dataTest= np.genfromtxt('data_test_PNN.txt', skip_header=1)

dataX = dataSet[:,0]
dataY = dataSet[:,1]
dataZ = dataSet[:,2]
dataClass = dataSet[:,3]

uniqueClass = list(set(dataClass))

def euclidean(data1, data2):
    decX = (data1[0]-data2[0])**2
    decY = (data1[1]-data2[1])**2
    decZ = (data1[2]-data2[2])**2
    return np.sqrt(decX + decY + decZ)

def separateCol(data, dataSet, col):
    separatedClass = []
    for i, Class in enumerate(data):
        classes = []
        for y, rowData in enumerate(dataSet):
            if (rowData[col] == Class):
                classes.append(rowData)
        separatedClass.append(classes)
    return separatedClass

def neighborDistance(separatedClass):
    dataDistances = []
    for i, aClass in enumerate(separatedClass):
        dataClassDistance = []
        for y, row in enumerate(aClass):
            distances = []
            for z, insideRow in enumerate(aClass):
                if (y != z):
                    euc = euclidean(row, insideRow)
                    distances.append(euc)
            tmp = np.append(row, min(distances))
            dataClassDistance.append(tmp)
        dataDistances.append(dataClassDistance)
    dataDistances = np.concatenate((dataDistances))
    return dataDistances

def sumCol(data, col):
    dataSumDistances = []
    for i, val in enumerate(data):
        # sum all item in an array in column = 1
        dataSumDistances.append(sum(row[col] for row in val))
    return dataSumDistances

def cariF(g, dataSumDistances, separatedDataTrain):
    dataF = []
    for i, val in enumerate(dataSumDistances):
        dataF.append(float(g * dataSumDistances[i])/len(separatedDataTrain[i]))
    return(dataF)

def cariG(test, dataTrain, dataF):
    dataG = []
    for y, rowTest in enumerate(test):
        for i, rowTrain in enumerate(dataTrain):
            typeClass = rowTrain[3]
            print('typeClass ', typeClass)
            calc = np.exp(-1 * (((rowTest[0] - rowTrain[0])**2) + ((rowTest[1] - rowTrain[1]) ** 2) + ((rowTest[2] - rowTrain[2]) ** 2)) / 2 * (dataF[int(typeClass)]) ** 2)
            tmp = np.append(rowTrain, calc)
            dataG.append(tmp)
    return dataG

def ValidationTest(dataTest, resultTest, g):
    count = 0
    countDataTest = len(dataTest)
    for i, val in enumerate(dataTest):
        if (val[3] == resultTest[i]):
            count += 1
    return count/countDataTest, g

# =============================================================================
# Data Preparation
# =============================================================================
z1separatedClass = separateCol(uniqueClass, dataSet, 3)
z2dataDistances = neighborDistance(z1separatedClass)
# -----------------------------------------------------------------------------

# Split Data train
Data_train, Data_test = train_test_split(z2dataDistances, test_size = 0.2)

separatedDataTrainClasses = separateCol(uniqueClass, Data_train, 3)

dataTrainDistClass = np.array(Data_train)[:, (3, 4)]

separatedDataTrain = separateCol(uniqueClass, dataTrainDistClass, 0)

dataSumDistances = sumCol(separatedDataTrain, 1)
